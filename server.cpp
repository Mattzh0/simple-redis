// stdlib
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

// system
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>

// C++
#include <vector>

const size_t k_max_msg = 32 << 20; // likely larger than the kernel buffer

struct Conn {
	int fd = -1;
	// application's intention (for use in the event loop)
	bool want_read = false;
	bool want_write = false;
	bool want_close = false;
	// buffers for input and ouptut
	// use uint8_t because it best represents raw memory bytes; 1 byte = 8 bits
	std::vector<uint8_t> incoming; // data to be parsed by the application
	std::vector<uint8_t> outgoing; // responses to be generated by the application
};

static void die(const char* msg) {
	fprintf(stderr, "[errno: %d] %s\n", errno, msg);
	abort();
}

static void msg_errno(const char *msg) {
    fprintf(stderr, "[errno:%d] %s\n", errno, msg);
}

static void msg(const char *msg) {
    fprintf(stderr, "%s\n", msg);
}

static void fd_set_nb(int fd) {
	errno = 0;
	int flags = fcntl(fd, F_GETFL, 0); // get the current flags of the file descriptor
	if (errno) {
		die("fcntl error");
		return;
	}

	flags |=  O_NONBLOCK; // apply non-blocking mode

	errno = 0;
	(void) fcntl(fd, F_SETFL, flags); // update the flags of the file descriptor
	if (errno) {
		die("fcntl error");
	}
}

// append data to the back of a buffer
static void buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len) {
	buf.insert(buf.end(), data, data + len);
}

// remove data from the front of a buffer
static void buf_consume(std::vector<uint8_t> &buf, size_t n) {
    buf.erase(buf.begin(), buf.begin() + n);
}

// application callback for when the listening socket is ready
static Conn *handle_accept(int fd) {
	struct sockaddr_in client_addr = {};
	socklen_t addr_len = sizeof(client_addr);

	int connfd = accept(fd, (struct sockaddr *)&client_addr, &addr_len);
	if (connfd < 0) {
		msg_errno("accept() error");
		return NULL;
	}

	uint32_t ip = client_addr.sin_addr.s_addr;
	fprintf(stderr, "new client from %u.%u.%u.%u:%u\n",
        ip & 255, (ip >> 8) & 255, (ip >> 16) & 255, ip >> 24,
        ntohs(client_addr.sin_port)
    );

    // set the new connection fd to nonblocking mode
    fd_set_nb(connfd);

    // create a connection struct
    Conn *conn = new Conn();
    conn->fd = connfd;
    conn->want_read = true;
    return conn;

}

// process one request if there is enough data
static bool try_one_request(Conn *conn) {
	// try to parse the message header (4 bytes, contains the size)
	if (conn->incoming.size() < 4) {
		return false; // not enough data
	}

	uint32_t len = 0;
	memcpy(&len, conn->incoming.data(), 4);
	if (len > k_max_msg) {
		msg("too long");
		conn->want_close = true;
		return false;
	}

	// message body
	if (len + 4 > conn->incoming.size()) {
		return false; // not enough data
	}

	const uint8_t *request = &conn->incoming[4];

	// got one request, do some application logic
    printf("client says: len:%d data:%.*s\n", len, len < 100 ? len : 100, request);

    // generate and echo the response
    buf_append(conn->outgoing, (const uint8_t *)&len, 4);
    buf_append(conn->outgoing, request, len);

    // application logic done, remove the request message
    buf_consume(conn->incoming, 4 + len);

    return true; // success

}

// application callback whent he socket is writable
static void handle_write(Conn *conn) {
 	assert(conn->outgoing.size() > 0);

 	ssize_t res = write(conn->fd, &conn->outgoing[0], conn->outgoing.size());

 	// actually not ready
 	if (res < 0 && errno == EAGAIN) {
 		return;
 	}

 	if (res < 0) {
 		msg_errno("write() error");
 		conn->want_close = true;
 		return;
 	}

 	// remove the written data from the outgoing buffer
 	buf_consume(conn->outgoing, (size_t)res);

 	// update the readiness intention
 	if (conn->outgoing.size() == 0) { // all data has been written
 		conn->want_read = true;
 		conn->want_write = false;

 	}
}

// application callback when the socket is readable
static void handle_read(Conn *conn) {
	// read some data
	uint8_t buf[64 * 1024];
	ssize_t res = read(conn->fd, buf, sizeof(buf));

	// actually not ready
	if (res < 0 && errno == EAGAIN) {
		return;
	}

	if (res < 0) {
		msg_errno("read() error");
		conn->want_close = true;
		return;
	}

	// handle EOF
	if (res == 0) {
		if (conn->incoming.size() == 0) {
			msg("client closed");
		}
		else {
			msg("unexpected EOF");
		}
		conn->want_close = true;
		return;
	}

	// got new data, add to incoming buffer
	buf_append(conn->incoming, buf, (size_t)res);

	// parse the request and generate reponses
	// call this in a loop because of pipelining...
	while (try_one_request(conn)) {}

	// update readiness intentions
	if (conn->outgoing.size() > 0) {
		conn->want_read = false;
		conn->want_write = true;

		// socket is likely ready to write in a request-response protocol
		// try to write without waiting for the next iteration
		return handle_write(conn);
	}

}

int main() {
	// create the listening socket
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0) {
		die("socket()");
	}

	// set socket options
	// val = 1 means enable the SO_REUSEADDR option, val = 0 means disable
	// if the server is stopped we can't start it again, as the port stays reserved to make sure that all lingering packets are flushed
	// SO_REUSEADDR overrides this, allowing the port to be reused anyway without waiting
	int val = 1;
	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));

	// bind socket to address
	struct sockaddr_in addr = {};
	addr.sin_family = AF_INET;
	addr.sin_port = ntohs(1234);
	addr.sin_addr.s_addr = ntohl(0); // wildcard address 0.0.0.0
	int res = bind(fd, (sockaddr *)&addr, sizeof(addr));
	if (res) {
		die("bind()"); // rv should be zero if bind was successful
	}

	// set the listening socket to be on nonblocking mode
	// program never blocks when the socket is being used
	// we want an event loop where we can service multiple clients
	fd_set_nb(fd);

	// listen
	res = listen(fd, SOMAXCONN);
	if (res) {
		die("listen error");
	}

	// map: fd -> client connection
	std::vector<Conn *> fd2conn;
	// array of all file descriptors, used as input to poll()
	std::vector<struct pollfd> poll_args;

	// event loop
	while (true) {
		// prepare arguments of poll()
		poll_args.clear(); // fresh restart for the current iteration

		// create the listening socket, which will go in the first position
		struct pollfd pfd = {fd, POLLIN, 0};
		poll_args.push_back(pfd);

		// all subsequent sockets are for client connections
		for (Conn *conn : fd2conn) {
			if (!conn) {
				continue;
			}

			struct pollfd pfd = {conn->fd, POLLERR, 0};

			// set read intent if applicable
			if (conn->want_read) {
				pfd.events |= POLLIN;
			}

			// set write intent if applicable
			if (conn->want_write) {
				pfd.events |= POLLOUT;
			}

			// push into the array of file descriptors
			poll_args.push_back(pfd);
		}

		// wait for readiness
		int res = poll(poll_args.data(), (nfds_t)poll_args.size(), -1);

		if (res < 0 && errno == EINTR) {
			continue; // not an error, "soft restart" as a result of a signal being received
		}

		if (res < 0) {
			die("poll");
		}

		// listening socket handles new client connections
		if (poll_args[0].revents) {
			if (Conn *conn = handle_accept(fd)) {
				if (fd2conn.size() <= (size_t)conn->fd) {
					fd2conn.resize(conn->fd + 1);
				}
				assert(!fd2conn[conn->fd]); // entry must not exist already
				fd2conn[conn->fd] = conn; // add new client connection to fd2conn
			}
		}

		// handle connection sockets
		for (size_t i = 1; i < poll_args.size(); i++) {
			uint32_t ready = poll_args[i].revents;
			if (ready == 0) {
				continue;
			}

			Conn *conn = fd2conn[poll_args[i].fd];
			if (ready & POLLIN) {
				assert(conn->want_read);
				handle_read(conn);
			}
			if (ready & POLLOUT) {
				assert(conn->want_write);
				handle_write(conn);
			}

			if ((ready & POLLERR) || conn->want_close) {
				(void)close(conn->fd); // casting to void helps suppress compiler warnings, as the function returns 0 for success and -1 for error
				fd2conn[conn->fd] = NULL;
				delete conn;
			}
		}

		return 0;
	}

}

/*
	Lifecycle Runthrough

	Iteration 1 - Part 1
	- fd2conn starts off empty
	- Push the listening socket to poll_args (index 0)
	- Loop through fd2conn (which is empty, so nothing is done)
	- poll() executes and stalls until a new connection is received on the listening socket

	Iteration 1 - Part 2
	- Client connects and poll() wakes up
	- We check poll_args[0].revents, which is ready
	- Call handle_accept(fd), creating a new Conn object and storing it in fd2conn

	Iteration 2 and Beyond
	- Loop restarts, and poll_args is cleared
	- Listening socket pushed to poll_args
	- Loop through fd2conn which now is not empty, containing the client from the previous iteration
	- Read the client's state (want_read/want_write) and push a pollfd to poll_args
	- poll_args now has size 2, so poll() executes and stalls for both the listening and client sockets
*/